/*
Package main GENERATED BY gengo:runtimedoc
DON'T EDIT THIS FILE
*/
package main

// nolint:deadcode,unused
func runtimeDoc(v any, names ...string) ([]string, bool) {
	if c, ok := v.(interface {
		RuntimeDoc(names ...string) ([]string, bool)
	}); ok {
		return c.RuntimeDoc(names...)
	}
	return nil, false
}

func (v Agent) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Otel":
			return []string{}, true
		case "KubeClient":
			return []string{}, true
		case "Server":
			return []string{}, true

		}
		if doc, ok := runtimeDoc(v.Otel, names...); ok {
			return doc, ok
		}
		if doc, ok := runtimeDoc(v.KubeClient, names...); ok {
			return doc, ok
		}
		if doc, ok := runtimeDoc(v.Server, names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{
		"Serve kubepkg agent",
	}, true
}

func (v Apply) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Logger":
			return []string{}, true
		case "Apply":
			return []string{}, true

		}
		if doc, ok := runtimeDoc(v.Logger, names...); ok {
			return doc, ok
		}
		if doc, ok := runtimeDoc(v.Apply, names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{
		"Apply manifests to k8s directly",
	}, true
}

func (v Dashboard) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Otel":
			return []string{}, true
		case "Sign":
			return []string{}, true
		case "Auth":
			return []string{}, true
		case "AuthProviderOidc":
			return []string{}, true
		case "DB":
			return []string{}, true
		case "Server":
			return []string{}, true

		}
		if doc, ok := runtimeDoc(v.Otel, names...); ok {
			return doc, ok
		}
		if doc, ok := runtimeDoc(v.Server, names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{
		"Serve kubepkg dashboard",
	}, true
}

func (v Export) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Logger":
			return []string{}, true
		case "Exporter":
			return []string{}, true

		}
		if doc, ok := runtimeDoc(v.Logger, names...); ok {
			return doc, ok
		}
		if doc, ok := runtimeDoc(v.Exporter, names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{
		"BindKubepkg kubepkg.tgz from kubepkg manifest",
	}, true
}

func (v Exporter) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "KubepkgJSON":
			return []string{}, true
		case "Storage":
			return []string{}, true
		case "RemoteRegistry":
			return []string{}, true
		case "ForceResolve":
			return []string{
				"Ignore image locked sha256 digest",
			}, true
		case "Output":
			return []string{
				"Output path for kubepkg.tgz",
			}, true
		case "ExtractManifestsYaml":
			return []string{
				"Extract manifests as yaml",
			}, true
		case "Platform":
			return []string{
				"Supported platforms",
			}, true

		}

		return nil, false
	}
	return []string{}, true
}

func (v Import) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Logger":
			return []string{}, true
		case "Importer":
			return []string{}, true

		}
		if doc, ok := runtimeDoc(v.Logger, names...); ok {
			return doc, ok
		}
		if doc, ok := runtimeDoc(v.Importer, names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{
		"import kubepkg.tgz or kubepkg.{json,yaml}",
	}, true
}

func (v Importer) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "KubepkgSpecOrTgz":
			return []string{}, true
		case "ImportTo":
			return []string{
				"Import to. REMOTE_AGENT (http://ip:port) or STORAGE_ROOT (dir path)",
			}, true
		case "Namespace":
			return []string{
				"Namespace Force overwrites Namespaces of resources",
			}, true
		case "Incremental":
			return []string{
				"Only for importing to REMOTE_AGENT",
			}, true
		case "SkipBlobs":
			return []string{
				"Only for importing to REMOTE_AGENT without blobs, when --incremental set",
			}, true
		case "ManifestOutput":
			return []string{
				"Dir to output manifest. Only for importing to STORAGE_ROOT",
			}, true

		}

		return nil, false
	}
	return []string{}, true
}

func (v Manifests) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "PrintManifests":
			return []string{}, true

		}
		if doc, ok := runtimeDoc(v.PrintManifests, names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{
		"Show manifests",
	}, true
}

func (v Operator) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Otel":
			return []string{}, true
		case "KubeClient":
			return []string{}, true
		case "Operator":
			return []string{}, true

		}
		if doc, ok := runtimeDoc(v.Otel, names...); ok {
			return doc, ok
		}
		if doc, ok := runtimeDoc(v.KubeClient, names...); ok {
			return doc, ok
		}
		if doc, ok := runtimeDoc(v.Operator, names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{
		"Serve Operator",
	}, true
}

func (v PrintManifests) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Namespace":
			return []string{}, true
		case "KubepkgJSON":
			return []string{}, true

		}

		return nil, false
	}
	return []string{}, true
}

func (v Registry) RuntimeDoc(names ...string) ([]string, bool) {
	if len(names) > 0 {
		switch names[0] {
		case "Otel":
			return []string{}, true
		case "Server":
			return []string{}, true

		}
		if doc, ok := runtimeDoc(v.Otel, names...); ok {
			return doc, ok
		}
		if doc, ok := runtimeDoc(v.Server, names...); ok {
			return doc, ok
		}

		return nil, false
	}
	return []string{
		"Container Registry",
	}, true
}
